"use server"

import { ActionState } from "@/types"
import { openai } from "@ai-sdk/openai"
import { generateText } from "ai"
import { scrapeWebsiteAction } from "@/actions/integrations/firecrawl/website-scraping-actions"
import { KEYWORD_CONFIG } from "@/lib/config/keyword-config"
import { db } from "@/db/db"
import { collection, doc, serverTimestamp, setDoc } from "firebase/firestore"
import { KEYWORD_PERFORMANCE_COLLECTIONS, CreateKeywordPerformanceData } from "@/db/firestore/keyword-performance-collections"
import { generateUUID } from "@/lib/utils"
import { auth } from "@clerk/nextjs/server"

interface GenerateKeywordsData {
  website?: string
  businessDescription?: string
  refinement?: string
  organizationId: string // Now required
  campaignId?: string // Optional campaign association
}

interface KeywordsResult {
  keywords: string[]
  coreProblem: string
  customerGroups: string[]
  // Backwards compatibility
  idealCustomerProfile: string
  uniqueValueProposition: string
  targetPainPoints: string[]
}

export async function generateKeywordsAction({
  website,
  businessDescription,
  refinement = "",
  organizationId,
  campaignId
}: GenerateKeywordsData): Promise<ActionState<KeywordsResult>> {
  try {
    console.log("üîç [KEYWORDS] Generating keywords")
    console.log("üîç [KEYWORDS] Website:", website || "None")
    console.log(
      "üîç [KEYWORDS] Business Description:",
      businessDescription ? "Provided" : "None"
    )
    console.log("üîç [KEYWORDS] Refinement:", refinement)
    console.log("üîç [KEYWORDS] Organization ID:", organizationId)
    console.log("üîç [KEYWORDS] Campaign ID:", campaignId || "None")

    // Validate organizationId
    if (!organizationId) {
      console.error("üîç [KEYWORDS] No organization ID provided")
      return {
        isSuccess: false,
        message: "Organization ID is required"
      }
    }

    // Get current user
    const { userId } = await auth()
    if (!userId) {
      console.error("üîç [KEYWORDS] No user ID from auth")
      return {
        isSuccess: false,
        message: "Authentication required"
      }
    }

    const businessInfo = businessDescription
      ? `Business Description: ${businessDescription}`
      : website
        ? `Website: ${website}`
        : "No business information provided"
        
    const requestedCount = refinement?.match(/Generate (?:exactly )?(\d+) (?:diverse )?keywords/i)
      ? parseInt(refinement.match(/Generate (?:exactly )?(\d+) (?:diverse )?keywords/i)![1])
      : 10;

    const prompt = `system:\nYou are a growth hacker. Goal: surface Reddit conversations where users expose intent for the business below.\nThink in 3 steps and OUTPUT JSON only.\n1) ü§î Reason about language patterns target users use.\n2) üß™ Generate candidate queries (each with reach & signal estimate 0-1). Produce N√ó2 queries (broad & narrow) where N=${requestedCount}.\n3) ü©∫ Score candidate with harmonic_mean(signal, log10(reach+1)).\nReturn {\n  "candidates":[{\n      "q":"string",\n      "reach":0.0,\n      "signal":0.0,\n      "score":0.0,\n      "rationale":"string"\n  }...]\n}\nuser:\n${businessInfo}\n${refinement}`

    const result = await generateText({
      model: openai("gpt-4o-mini"),
      system:
        "You are a Reddit search query expert. Generate natural language search queries that will find Reddit posts from people seeking help. NEVER use quotes or OR operators as they limit results. Focus on how people actually write on Reddit. Return only valid JSON objects.",
      prompt: prompt,
      temperature: 0.7,
    })

    const response = result.text
    if (!response) {
      throw new Error("No response from OpenAI")
    }

    let parsedResponse: KeywordsResult
    try {
      const rawParsed = JSON.parse(response);
      let keywordsArray: string[] = []
      if (rawParsed.keywords && Array.isArray(rawParsed.keywords)) {
        keywordsArray = rawParsed.keywords
      } else if (rawParsed.candidates && Array.isArray(rawParsed.candidates)) {
        // Sort candidates by score desc then pick requestedCount
        rawParsed.candidates.sort((a: any, b: any) => b.score - a.score)
        keywordsArray = rawParsed.candidates.slice(0, requestedCount).map((c: any) => c.q)
      }
      if (keywordsArray.length === 0) {
        throw new Error("No keywords generated by AI response")
      }

      parsedResponse = {
        keywords: keywordsArray,
        coreProblem: rawParsed.coreProblem || "",
        customerGroups: rawParsed.customerGroups || [],
        idealCustomerProfile: rawParsed.idealCustomerProfile || "",
        uniqueValueProposition: rawParsed.uniqueValueProposition || "",
        targetPainPoints: rawParsed.targetPainPoints || []
      }
      
      if (parsedResponse.keywords.length > requestedCount) {
        parsedResponse.keywords = parsedResponse.keywords.slice(0, requestedCount);
      }
      while (parsedResponse.keywords.length < requestedCount && parsedResponse.keywords.length > 0) {
        parsedResponse.keywords.push(parsedResponse.keywords[parsedResponse.keywords.length - 1] + " variation"); 
      }
      if (parsedResponse.keywords.length === 0 && requestedCount > 0) {
          parsedResponse.keywords = [`${businessDescription || website || 'general search'} help`];
          while(parsedResponse.keywords.length < requestedCount) parsedResponse.keywords.push(`${parsedResponse.keywords[0]} ${parsedResponse.keywords.length+1}`) 
      }

    } catch (parseError) {
      console.error("üîç [KEYWORDS] Failed to parse AI response:", response, parseError)
      throw new Error("Invalid response format from AI. Could not parse strategic insights and keywords.")
    }

    console.log(`üîç [KEYWORDS] Generated ${parsedResponse.keywords.length} keywords and strategic insights.`)

    // Persist keyword performance stub for future tracking
    const perfId = generateUUID()
    const perfData: CreateKeywordPerformanceData = {
      userId: userId,
      organizationId: organizationId, // Now always provided
      campaignId,
      keywords: parsedResponse.keywords
    }
    
    try {
      const perfRef = doc(collection(db, KEYWORD_PERFORMANCE_COLLECTIONS.KEYWORD_PERFORMANCE), perfId)
      await setDoc(perfRef, {
        ...perfData,
        id: perfId,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      })
      console.log("üîç [KEYWORDS] Created keyword performance document:", perfId)
    } catch (perfErr) {
      console.error("[KEYWORD-PERF] Failed to write performance doc", perfErr)
      // Don't fail the whole operation if performance tracking fails
    }

    return {
      isSuccess: true,
      message: "Keywords and strategic insights generated successfully",
      data: parsedResponse
    }
  } catch (error) {
    console.error("üîç [KEYWORDS] Error:", error)
    return {
      isSuccess: false,
      message:
        error instanceof Error ? error.message : "Failed to generate keywords and insights"
    }
  }
}

function extractKeywordsFromText(text: string): string[] {
  console.log("üîç [KEYWORDS-ACTION] extractKeywordsFromText called")
  console.log("üîç [KEYWORDS-ACTION] Input text:", text)

  // Clean the text to remove markdown if present
  let cleanText = text.trim()
  if (cleanText.startsWith("```json")) {
    cleanText = cleanText.replace(/^```json\s*/, "").replace(/\s*```$/, "")
  } else if (cleanText.startsWith("```")) {
    cleanText = cleanText.replace(/^```\s*/, "").replace(/\s*```$/, "")
  }

  const keywords: string[] = []

  console.log("üîç [KEYWORDS-ACTION] Processing cleaned text")

  // Try to extract from JSON structure first
  try {
    const jsonMatch = cleanText.match(/"keywords"\s*:\s*\[([\s\S]*?)\]/)
    if (jsonMatch) {
      console.log("üîç [KEYWORDS-ACTION] Found keywords array in JSON structure")
      const keywordsString = jsonMatch[1]
      const keywordMatches = keywordsString.match(/"([^"]+)"/g)
      if (keywordMatches) {
        keywordMatches.forEach(match => {
          const keyword = match.replace(/"/g, "")
          keywords.push(keyword)
          console.log(
            "üîç [KEYWORDS-ACTION] Extracted keyword from JSON:",
            keyword
          )
        })
      }
    }
  } catch (error) {
    console.log(
      "üîç [KEYWORDS-ACTION] JSON extraction failed, trying line-by-line"
    )
  }

  // Fallback to line-by-line extraction if JSON extraction failed
  if (keywords.length === 0) {
    const lines = cleanText.split("\n")
    console.log("üîç [KEYWORDS-ACTION] Processing", lines.length, "lines")

    for (const line of lines) {
      // Look for lines that start with - or numbers or quotes
      if (
        line.match(/^[-*‚Ä¢]\s*".*"/) ||
        line.match(/^\d+\.\s*".*"/) ||
        line.match(/^\s*".*",?\s*$/)
      ) {
        const match = line.match(/"([^"]+)"/)
        if (match) {
          console.log("üîç [KEYWORDS-ACTION] Found keyword:", match[1])
          keywords.push(match[1])
        }
      }
    }
  }

  console.log("üîç [KEYWORDS-ACTION] Extracted keywords:", keywords)

  // If no keywords found, return empty array
  if (keywords.length === 0) {
    console.log("üîç [KEYWORDS-ACTION] No keywords found in the provided text")
    return []
  }

  const finalKeywords = keywords.slice(0, 10) // Limit to 10 keywords
  console.log("üîç [KEYWORDS-ACTION] Final keywords:", finalKeywords)
  return finalKeywords
}
